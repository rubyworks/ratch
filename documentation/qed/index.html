<html>
<head>
  <title>Ratch</title>

  <!-- TODO: most of the css before the '*' can be removed. -->

  <style>
    #container{ margin: 0 auto; width: 800px; }

    /* Debug borders */
    /* p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 { border: 1px solid red; } */

    body { font-size: 14px; line-height: 20px; margin: 1em 5% 1em 5%; font-family: Verdana, Arial, Helvetica, sans-serif; }
    a { color: #336; text-decoration: underline; }
    a:visited { color: #334; }
    em { font-style: italic; }
    strong { font-weight: bold; }
    tt { color: navy; }

    h1, h2, h3, h4, h5, h6 { color: #223; margin-top: 1.2em; margin-bottom: 0.5em; line-height: 1.3; }
    h1 { border-bottom: 2px solid silver; }
    h2 { border-bottom: 2px solid silver; padding-top: 0.5em; }

    hr { color: #ccc; margin-top: 1.6em; }

    p { color: #222; text-align: justify; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.4em; }

    /* pre { padding: 10; margin: 0; font-family: monospace; font-size: 0.9em; } */

    pre.pass { color: green; }
    pre.fail { color: red; }
    pre.error { color: red; font-weight: bold; }

    span#author { color: #527bbd; font-weight: bold; font-size: 1.1em; }
    span#email { }
    span#revision { }

    div#footer { font-size: small; border-top: 2px solid silver; padding-top: 0.5em; margin-top: 4.0em; }
    div#footer-text { float: left; padding-bottom: 0.5em; }
    div#footer-badges { float: right; padding-bottom: 0.5em; }

    /* Block element content. */
    div.content { padding: 0; }

    /* Block element titles. */
    h1.title { font-weight: bold; text-align: left; font-size: 3em; margin-top: 1.0em; margin-bottom: 0.5em; }

    /* Block element titles. */
    div.title, caption.title { font-weight: bold; text-align: left; margin-top: 1.0em; margin-bottom: 0.5em; }
    div.title + * { margin-top: 0; }
    td div.title:first-child { margin-top: 0.0em; }
    div.content div.title:first-child { margin-top: 0.0em; }
    div.content + div.title { margin-top: 0.0em; }
    div.sidebarblock > div.content { background: #ffffee; border: 1px solid silver; padding: 0.5em; }

    img { border-style: none; }

    dl { margin-top: 0.8em; margin-bottom: 0.8em; }
    dt { margin-top: 0.5em; margin-bottom: 0; font-style: italic; }
    dd > *:first-child { margin-top: 0; }
    ul, ol { list-style-position: outside; }

    thead { font-weight: bold; }
    tfoot { font-weight: bold; }

    *{margin:0;padding:0;}
    html,body{height:100%;color:black;}
    body{background-color:white;font:13.34px helvetica,arial,freesans,clean,sans-serif;*font-size:small;}
    table{font-size:inherit;font:100%;}
    select,input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}
    select,option{padding:0 .25em;}
    optgroup{margin-top:.5em;}
    input.text{padding:1px 0;}
    pre,code{font:12px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;}
    body *{line-height:1.4em;}
    p{margin:1em 0;}
    img{border:0;}
    abbr{border-bottom:none;}

    .wikistyle h1,.wikistyle h2,.wikistyle h3,.wikistyle h4,.wikistyle h5,.wikistyle h6{border:0!important;}
    .wikistyle h1{font-size:170%!important;border-top:4px solid #aaa!important;padding-top:.5em!important;margin-top:1.5em!important;}
    .wikistyle h1:first-child{margin-top:0!important;padding-top:.25em!important;border-top:none!important;}
    .wikistyle h2{font-size:150%!important;margin-top:1.5em!important;border-top:4px solid #e0e0e0!important;padding-top:.5em!important;}
    .wikistyle h3{margin-top:1em!important;}
    .wikistyle p{margin:1em 0!important;line-height:1.5em!important;}
    .wikistyle ul{margin:1em 0 1em 2em!important;}
    .wikistyle ol{margin:1em 0 1em 2em!important;}
    .wikistyle ul ul,.wikistyle ul ol,.wikistyle ol ol,.wikistyle ol ul{margin-top:0!important;margin-bottom:0!important;}
    .wikistyle blockquote{margin:1em 0!important;border-left:5px solid #ddd!important;padding-left:.6em!important;color:#555!important;}
    .wikistyle dt{font-weight:bold!important;margin-left:1em!important;}
    .wikistyle dd{margin-left:2em!important;margin-bottom:1em!important;}
    .wikistyle table{margin:1em 0!important;}
    .wikistyle table th{border-bottom:1px solid #bbb!important;padding:.2em 1em!important;}
    .wikistyle table td{border-bottom:1px solid #ddd!important;padding:.2em 1em!important;}
    .wikistyle pre{margin:1em 0!important;font-size:90%!important;background-color:#f8f8ff!important;border:1px solid #dedede!important;padding:.5em!important;line-height:1.5em!important;color:#444!important;overflow:auto!important;}
    .wikistyle pre code{padding:0!important;font-size:100%!important;background-color:#f8f8ff!important;border:none!important;}
    .wikistyle code{font-size:90%!important;background-color:#f8f8ff!important;color:#444!important;padding:0 .2em!important;border:1px solid #dedede!important;}
    .wikistyle pre.console{margin:1em 0!important;font-size:90%!important;background-color:black!important;padding:.5em!important;line-height:1.5em!important;color:white!important;}
    .wikistyle pre.console code{padding:0!important;font-size:100%!important;background-color:black!important;border:none!important;color:white!important;}
    .wikistyle pre.console span{color:#888!important;}
    .wikistyle pre.console span.command{color:yellow!important;}

    .title { font-size: 2em; }
  </style>

  <!-- TODO: only include if these files exists -->
  <link href="../assets/styles/spec.css" type="text/css" rel="stylesheet">
  <!-- spec.css might be a problem with clobber -->
  <link href="spec.css" type="text/css" rel="stylesheet">

  

  <!-- JQuery is needed -->
  <script src="jquery.js" type="text/javascript" language="javascript"></script>

</head>

<body class="wikistyle">

  <!-- Side Table of Contents -->
  <div id="sidebar" style="position: fixed; top: 10; right: 10; background: white;">
    <a href="javascript: toc_toggle();">
      <img src="img/icon/book.jpg" height="30px;" style="border: none;" alt="TOC" align="right"/>
    </a>

    <div id="toc_side" class="toc">
    </div>
  </div>

  <div id="container">
    <div id="header">
      <img src="img/icon/book.jpg" align="left" style="padding-right: 10px;" alt=""/>

      <div class="title">Ratch</div>

      <h1>Table of Contents</h1>

      <div class="toc">
      </div>
    </div>

    <div id="content">
      <h1>Ratch::Shell</h1>
<p>
The Shell class mimics a basic shell command line prompt.
</p>
<pre>
  require 'ratch/shell'
</pre>
<p>
The demonstration sets up sample directory consisting of the following
entires in the tmp/qed directory:
</p>
<pre>
  foo.txt
  zoo/
  zoo/bar.txt
</pre>
<h2>Initial Path</h2>
<p>
When no path argument is provided to the initializer, the present working
path is used. The path is stored as a Pathname object.
</p>
<pre>
  shell = Ratch::Shell.new
  shell.work.assert = Pathname.new(Dir.pwd).expand_path
</pre>
<p>
Otherwise the path given is used.
</p>
<pre>
  shell = Ratch::Shell.new('.')
  shell.work.assert = Pathname.new('.').expand_path

  shell = Ratch::Shell.new('..')
  shell.work.assert = Pathname.new('..').expand_path
</pre>
<p>
An error is raise if the path does not exist.
</p>
<pre>
  expect Ratch::FileNotFound do
    Ratch::Shell.new('not_a_path')
  end
</pre>
<h2>Processing Options</h2>
<p>
The <tt>initialize</tt> method accepts a few options. The <tt>quiet</tt>
option supresses all output to stdout.
</p>
<pre>
  shell = Ratch::Shell.new(:quiet=&gt;true)
  shell.assert.quiet?
  
</pre>
<p>
The <tt>noop</tt> option prevents any actual writing to disk &#8212;the
process will simply pretend that it has done so.
</p>
<pre>
  shell = Ratch::Shell.new(:noop=&gt;true)
  shell.assert.noop? 
</pre>
<p>
The <tt>trace</tt> option provides step by step feedback on what is taking
place.
</p>
<pre>
  shell = Ratch::Shell.new(:trace=&gt;true)
  shell.assert.trace? 
</pre>
<p>
The <tt>dryrun</tt> option is simply a compbination of <tt>noop</tt> and
<tt>trace</tt>.
</p>
<pre>
  shell = Ratch::Shell.new(:dryrun=&gt;true)
  shell.assert.noop?
  shell.assert.trace?
  shell.assert.dryrun?
</pre>
<h2>Equality</h2>
<p>
For two Shell objects to be considered equal, via #==, they must both be
instances of Ratch::Shell (or subclass) and have the same working path.
</p>
<pre>
  shell1 = Ratch::Shell.new('.')
  shell2 = Ratch::Shell.new('.')
  shell1.assert = shell2

  shell1 = Ratch::Shell.new('.')
  shell2 = Ratch::Shell.new('..')
  shell1.refute = shell2
</pre>
<p>
The more strict #eql? method also ensures that the <tt>noop</tt> option is
the same.
</p>
<pre>
  shell1 = Ratch::Shell.new('.', :noop=&gt;true)
  shell2 = Ratch::Shell.new('.', :noop=&gt;true)
  shell1.assert.eql? shell2

  shell1 = Ratch::Shell.new('.', :noop=&gt;true)
  shell2 = Ratch::Shell.new('.', :noop=&gt;false)
  shell1.refute.eql? shell2
</pre>
<h2>File System Locations</h2>
<p>
The Shell class provides a few convenient methods for accessing common
locations in the file system, namely #work, #home, #parent and #root.
</p>
<pre>
  shell = Ratch::Shell.new

  shell.work.assert == Pathname.new('.').expand_path
  shell.parent.assert == Pathname.new('..').expand_path
</pre>
<p>
The current user&#8217;s home directoryis accessible via the #home method.
</p>
<pre>
  shell.home.assert == Pathname.new('~').expand_path
</pre>
<p>
The system&#8217;s root folder can be accessed via #root method.
</p>
<pre>
  shell.root.assert == Pathname.new('/').expand_path
</pre>
<p>
In addition the Shell class provides methods for accessing pathnames
relative to the current shell directory. The #path (or #pathname) method
returns a Pathname object with the given path.
</p>
<pre>
  shell.path('foo')
</pre>
<p>
This will work regardless if the path actually exists or not. On the other
hand, the #file and #dir methods will do the same, but will raise an error
if the path given is not an existing file or a directory, respectively.
</p>
<pre>
  shell.file('foo.txt')

  expect Ratch::FileNotFound do
    shell.file('not.txt')
  end

  shell.dir('zoo')

  expect Ratch::FileNotFound do
    shell.dir('not')
  end
</pre>
<h2>Entries</h2>
<p>
Shell#entries works just like Dir.entries except that each path is returned
as a Pathname object.
</p>
<pre>
  shell = Ratch::Shell.new

  shell.entries.assert == ['foo.txt', '.', '..', 'zoo'].map{|f| Pathname.new(f)}
</pre>
<p>
The #file_entries method limits the list to files only.
</p>
<pre>
  shell.file_entries.assert == ['foo.txt'].map{|f| Pathname.new(f)}
</pre>
<p>
Whereas #directory_entries (or #dir_entries) limits the list to
directories.
</p>
<pre>
  shell.directory_entries.assert == ['.', '..', 'zoo'].map{|f| Pathname.new(f)}
</pre>
<p>
Of course, having to deal with the &#8217;.&#8217; and &#8217;..&#8217; is
annoying most of the time so Shell provides more convenient methods. Like
#entries, #pathnames  provides a list of entries less the dot paths.
</p>
<pre>
  shell.pathnames.assert == ['foo.txt', 'zoo'].map{|f| Pathname.new(f)}
</pre>
<p>
The #directories (also #folders) method limits this list to directories
only.
</p>
<pre>
  shell.directories.assert == ['zoo'].map{|f| Pathname.new(f)}
</pre>
<p>
And #files works out to be the same as #file_entires.
</p>
<pre>
  shell.files.assert == ['foo.txt'].map{|f| Pathname.new(f)}
</pre>
<h2>Globbing</h2>
<pre>
  shell = Ratch::Shell.new

  shell.glob('*').assert == ['foo.txt', 'zoo']
</pre>
<h2>File Testing</h2>
<p>
Shell provides an interface to most of FileTest&#8217;s functions. 
</p>
<pre>
  shell.assert.exist?('foo.txt')
  shell.assert.file?('foo.txt')
  shell.refute.directory?('foo.txt')
  shell.assert.directory?('zoo')
</pre>
<h2>File IO</h2>
<p>
Shell can be used to easily read the contents of a file.
</p>
<pre>
  shell = Ratch::Shell.new

  shell.read('foo.txt').assert == 'SAMPLE FOO.TXT'
</pre>
<p>
As well as write a new file.
</p>
<pre>
  shell.write('baz.txt', 'BAZ TEXT')
  shell.read('baz.txt').assert == 'BAZ TEXT'
</pre>
<p>
Or append to an existing file.
</p>
<pre>
  shell.append('baz.txt', ' 2')
  shell.read('baz.txt').assert == 'BAZ TEXT 2'
</pre>
<p>
The shell command supports many file methods, including #rm.
</p>
<pre>
  shell.rm('baz.txt')
</pre>
<h2>System Calls</h2>
<p>
The Shell class can also call out to system commands. This is handled by
the Ratch::System class. See the system.rdoc file for details.
</p>

<h1>Ratch::Script</h1>
<p>
The Ratch::Script class is the context used for evaluating Ratch-based
batch files, aka shell scripts.
</p>
<pre>
  require 'ratch/script'
</pre>
<p>
In most every respect the Script class behaves like Ratch::Shell, except
that its initializer takes a file name to be evaluated.
</p>
<p>
Let&#8217;s say we have a Ratch script called &#8216;foo.ratch&#8217;:
</p>
<pre>
  #!/usr/bin/env ratch

  @test_message = &quot;Hello World!&quot;
</pre>
<p>
We can load the script via Ratch::Script.new.
</p>
<pre>
  script = Ratch::Script.new('foo.ratch')
</pre>
<p>
The file name can be accessed from the script using #script_file.
</p>
<pre>
  script.script_file.assert == 'foo.ratch'
</pre>
<p>
To execute a script, use the `#execute!` method, or it&#8217;s alias
`#run!`.
</p>
<pre>
  script.execute!
</pre>
<p>
We can see that the script did indeed execute by plubming for the instance
variable it set.
</p>
<pre>
  msg = script.instance_variable_get('@test_message')
  msg.assert == &quot;Hello World!&quot;
</pre>

<h1>Ratch::Batch</h1>
<p>
The Batch class makes makes it possible to work with multiple files at once
as easily as one would work with a single file.
</p>
<pre>
  require 'ratch/batch'
</pre>
<p>
The demonstration sets up a sample directory consisting of the following
entires in the temporary working directory:
</p>
<pre>
  foo.txt
  bar.txt
  zoo/
  zoo/one.txt
  zoo/two.txt
</pre>
<p>
To create a new Batch instance, pass the the base directory and any 
inclusion patterns to the initializer.
</p>
<pre>
  batch = Ratch::Batch.new('.', '*.txt')
</pre>
<p>
In this example we will get every `.txt` file at the toplevel of the base
directory.
</p>
<pre>
  batch.to_a.assert = ['foo.txt', 'bar.txt'].to_pathnames
</pre>
<p>
To get a list of files relative to the base directory, use #entries.
</p>
<pre>
  batch.entries.assert = ['foo.txt', 'bar.txt'].to_pathnames
</pre>
<p>
Internally a Batch instance tracks the files selected via a Ratch::FileList
object. This can be directly accessed via the #list method.
</p>
<pre>
  batch.file_list.assert.is_a?(Ratch::FileList)

  batch.file_list.to_a.assert = ['foo.txt', 'bar.txt']
</pre>
<p>
As with the delegated FileTest methods of the Shell class, Batch can test
the set of files in agregate. For example, to ensure all the entries are
files we can use the #file? method.
</p>
<pre>
  batch.assert.file?
</pre>
<p>
Likewise to enusre none the entires are directories we can use the
#directory? method.
</p>
<pre>
  batch.refute.directory?
</pre>
<p>
The Batch list can be reduced to just files or just directories via the
#file! and #directory! methods.
</p>
<pre>
  batch = Ratch::Batch.new('.', '*')
  batch.file!
  batch.list.assert = ['foo.txt', 'bar.txt']

  batch = Ratch::Batch.new('.', '*')
  batch.directory!
  batch.list.assert = ['zoo']
</pre>
<p>
The Batch class is enumerable, both #each and #size are defined.
</p>
<pre>
  batch = Ratch::Batch.new('.', '*.txt')

  batch.each do |pathname|
    pathname.assert.is_a?(Pathname)
  end

  batch.size.assert = 2
</pre>
<p>
Any enumerable method is likewise applicable.
</p>

<h1>Ratch::System</h1>


    </div>
  </div>

  <br/><br/><br/>
</body>

</html>

<script src="../assets/scripts/spec.js" type="text/javascript" language="javascript"></script>

<script type="text/javascript" language="javascript">
  /*****************************************************************
   * $.toc()
   * by rebecca murphey
   * rmurphey gmail com
   *
   * This function is called on its own and takes as an argument
   * a list of selectors with which it will build a table of
   * contents. 
   *
   * The first selector will make up the top level of the TOC;
   * the second selector will make up the second level of the TOC;
   * etc.
   *
   * This function returns a div containing nested unordered lists;
   * each list item is linked to an anchor tag added before the item
   * on the page.
   *
   * usage: $.toc('h1,h2,h3').prependTo('body');
   ************************************************************************/
  (function($) { 
    $.toc = function(tocList) {
      $(tocList).addClass('jquery-toc');
      var tocListArray = tocList.split(',');
      $.each(tocListArray, function(i,v) { tocListArray[i] = $.trim(v); });
      var $elements = $('.jquery-toc');
      $('body').append('<div></div>');
      var $toc = $('body div:last');
      var lastLevel = 1;
      $toc.append('<ul class="jquery-toc-1"></ul>');
      $elements.each(function() {
        var $e = $(this);
        var text = $e.text();
        var anchor = text.replace(/ /g,'-');
        $e.before('<a name="' + anchor + '"></a>');
        var level;
        $.each(tocListArray, function(i,v) { 
          if (v.match(' ')) {
            var vArray = v.split(' '); 
            var e = vArray[vArray.length - 1];
          } else { e = v; }
          if ($e.is(e)) { level = i+1; } 
        });
        var className = 'jquery-toc-' + level;
        var li = '<li><a href="#' + anchor + '">' + text + '</a></li>';
        if (level == lastLevel) {
          $('ul.' + className + ':last',$toc).append(li);
        } else if (level > lastLevel) {
          var parentLevel = level - 1;
          var parentClassName = 'jquery-toc-' + parentLevel;
          $('ul.' + parentClassName + ':last',$toc).
            append('<ul class="' + className + '"></ul>');
          $('ul.' + className + ':last',$toc).append(li);
        } else if (level < lastLevel) {
          $('ul.' + className + ':last',$toc).append(li);
        }
        lastLevel = level;
      });
      var $toc_ul = $('ul.jquery-toc-1',$toc);
      $toc.remove();
      return($toc_ul);
   }
  })(jQuery);
</script>

<script>
  function toc_toggle() {
    $('#toc_side').toggle();
    $("pre").addClass("pass");
    $("pre:contains('FAIL:')").addClass("fail");
    $("pre:contains('ERROR:')").addClass("error");
  };

  $.toc('#content h1,h2,h3,h4').appendTo('.toc');

  toc_toggle();
</script>

